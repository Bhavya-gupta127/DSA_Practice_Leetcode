class   Solution   { 
 public : 
 
      double   solve ( vector < int > &  nums1 ,  vector < int > &  nums2 )   { 
          int  n = nums1 . size ( ) + nums2 . size ( ) ; 
          //k1 and k2 are number of elements required before that ele 
          int  k = ( n ) / 2 ;  
          if ( n % 2 == 0 ) 
             k -- ; 
 
          int  l = 0 , h = nums1 . size ( ) - 1 , m1 , m2 ; 
          while ( l <= h ) 
          { 
             m1 = l + ( h - l ) / 2 ; 
              auto  it = upper_bound ( nums2 . begin ( ) , nums2 . end ( ) , nums1 [ m1 ] ) ; 
              if ( it != nums2 . end ( ) ) 
                 m2 = it - nums2 . begin ( ) ; 
              else 
                 m2 = nums2 . size ( ) ; 
              //elements before nums1[m1] are m1+m2 
              if ( m1 + m2 == k ) 
              { 
                  // cout<<nums1[m1]<<" "<<m1<<" "<<m2<<"\n"; 
                  double  ans = nums1 [ m1 ] ; 
                  if ( n % 2 == 0 ) 
                  { 
                      if ( m1 != nums1 . size ( ) - 1   &&  m2 < nums2 . size ( ) ) 
                         ans += min ( nums1 [ m1 + 1 ] , nums2 [ m2 ] ) ; 
                      else   if ( m2 < nums2 . size ( ) ) 
                         ans += nums2 [ m2 ] ; 
                      else   if ( m1 != nums1 . size ( ) - 1 ) 
                         ans += nums1 [ m1 + 1 ] ; 
                      return  ans / 2 ; 
                  } 
                  return  ans ; 
              } 
              else   if ( m1 + m2 < k ) 
              { 
                 l = m1 + 1 ; 
              } 
              else 
                 h = m1 - 1 ; 
          } 
 
          return   - 1 ; 
 
      } 
      double   solve2 ( vector < int > &  nums1 ,  vector < int > &  nums2 )   { 
          int  n = nums1 . size ( ) + nums2 . size ( ) ; 
          //k1 and k2 are number of elements required before that ele 
          int  k = ( n ) / 2 ;  
          if ( n % 2 == 0 ) 
             k -- ; 
 
          int  l = 0 , h = nums1 . size ( ) - 1 , m1 , m2 ; 
          while ( l <= h ) 
          { 
             m1 = l + ( h - l ) / 2 ; 
              auto  it = lower_bound ( nums2 . begin ( ) , nums2 . end ( ) , nums1 [ m1 ] ) ; 
              if ( it != nums2 . end ( ) ) 
                 m2 = it - nums2 . begin ( ) ; 
              else 
                 m2 = nums2 . size ( ) ; 
              //elements before nums1[m1] are m1+m2 
              if ( m1 + m2 == k ) 
              { 
                  // cout<<nums1[m1]<<" "<<m1<<" "<<m2<<"\n"; 
                  double  ans = nums1 [ m1 ] ; 
                  if ( n % 2 == 0 ) 
                  { 
                      if ( m1 != nums1 . size ( ) - 1   &&  m2 < nums2 . size ( ) ) 
                         ans += min ( nums1 [ m1 + 1 ] , nums2 [ m2 ] ) ; 
                      else   if ( m2 < nums2 . size ( ) ) 
                         ans += nums2 [ m2 ] ; 
                      else   if ( m1 != nums1 . size ( ) - 1 ) 
                         ans += nums1 [ m1 + 1 ] ; 
                      return  ans / 2 ; 
                  } 
                  return  ans ; 
              } 
              else   if ( m1 + m2 < k ) 
              { 
                 l = m1 + 1 ; 
              } 
              else 
                 h = m1 - 1 ; 
          } 
 
          return   - 1 ; 
 
      } 
 
      double   findMedianSortedArrays ( vector < int > &  nums1 ,  vector < int > &  nums2 )   { 
          // mediam is k=n+m/2 th smallest ele 
 
          // kth element 
          //  2 4 5 6 10 
          //  3 7 8 12  
 
          // apply bs on first array for each element find number of elements less than it in other array  
          // repeat for 2nd array 
          return   max ( { solve ( nums1 , nums2 ) , solve ( nums2 , nums1 ) , solve2 ( nums1 , nums2 ) , solve2 ( nums2 , nums1 ) } ) ; 
 
 
      } 
     
      // int checkleft(int ele,vector<int>&nums) 
      // { 
      //     int l=0; 
      //     int r=nums.size()-1; 
      //     int m; 
      //     int pos=0; 
      //     while(l<=r) 
      //     { 
      //         m=l+(r-l)/2; 
      //         if(nums[m]>ele) 
      //         { 
      //             pos=m; 
      //             r=m-1; 
      //         } 
      //         else 
      //             l=m+1; 
      //     } 
      //     return pos-1; 
      // } 
      // int findGreterEle(int ele,vector<int>&nums) 
      // { 
      //     int l=0; 
      //     int r=nums.size()-1; 
      //     int m; 
      //     int pos=0; 
      //     while(l<=r) 
      //     { 
      //         m=l+(r-l)/2; 
      //         if(nums[m]>ele) 
      //         { 
      //             pos=m; 
      //             r=m-1; 
      //         } 
      //         else 
      //             l=m+1; 
      //     } 
      //     return nums[pos]; 
      // } 
      // double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) { 
      //     // 1 3 5 6 7 8 9    1 2 5 8 10 
      //     // 1 2 3 5 5 6 7 8 8 9 10 
      //     int n1=nums1.size(); 
      //     int n2=nums2.size(); 
 
      //     int l1=0; 
      //     int r1=nums1.size()-1; 
      //     int m1; 
      //     double ans=-1; 
      //     while(l1<=r1) 
      //     { 
      //         m1=l1+(r1-l1)/2; 
      //         int ele=nums1[m1]; 
      //         int temp=checkleft(ele,nums2); 
      //         if(m1+l1==(n1+n2)/2) 
      //         { 
      //             if((n1+n2)%2==1) 
      //                 return (double)ele; 
      //             else 
      //             { 
      //                 if(m1==n1-1)  
      //                     return (findGreterEle(ele,nums2)+ele)/2; 
      //                 return (min(findGreterEle(ele,nums2),nums1[m1+1])+ele)/2; 
      //             } 
      //         } 
      //         else if(temp>n1/2) 
      //             r1=m1-1; 
      //         else 
      //             l1=m1+1; 
      //     } 
      //     return ans; 
      // } 
 } ;